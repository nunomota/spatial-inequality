<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>spatial_inequality.optimization.lookup API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spatial_inequality.optimization.lookup</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from collections import Counter

class Lookup:
    &#34;&#34;&#34;
    This class provides several fast lookup methods for both
    `optimization.entity_nodes.District` and `optimization.entity_nodes.School`
    instances. The underlying data structures are also updated dynamically to
    minimize computational complexity of certain operations (e.g., extracting
    districts&#39; neighborhoods from schools&#39; neighborhoods).

    Attributes:
        __school_dict (dict): Mapping between standardized school NCES IDs and
            their respective School instances.
        __district_dict (dict): Mapping between standardized district NCES IDs
            and their respective District instances.
        __assignment_dict (dict): Mapping between standardized school NCES IDs
            and the District instance they are assigned to.
        __bordering_dict (dict): Mapping between standardized district NCES IDs
            and School instances at their border (i.e., schools that neighbor
            other districts).
        __edge_tracker_matrix (numpy.ndarray): Square matrix (2-dimensional
            array), of &#39;districts x districts&#39; dimensions, that contains the
            amount of existing edges between any pair of districts.
        __district_id_to_edge_tracker_idx_dict (dict): Mapping between
            standardized district NCES IDs and their corresponding index in the
            __edge_tracker_matrix.
        __edge_tracker_idx_to_district_id_dict (dict): Mapping between a
            district&#39;s index in the __edge_tracker_matrix and their respective
            standardized NCES ID.
        __neighborhood_change_counter_dict (dict): Mapping between standardized
            district NCES IDs and the number of cumulative changes made in their
            neihborhood (i.e., number of schools redistricted).
        __all_schools_assigned (bool): Initialization flag to signal whether all
            schools have an assigned district
    &#34;&#34;&#34;
    __school_dict = None
    __district_dict = None
    __assignment_dict = None
    __bordering_dict = None
    __edge_tracker_matrix = None
    __district_id_to_edge_tracker_idx_dict = None
    __edge_tracker_idx_to_district_id_dict = None
    __neighborhood_change_counter_dict = None
    __all_schools_assigned = False
    
    def __init__(self, all_schools, all_districts):
        # Schools by ID
        self.__school_dict = {
            school.get_id(): school for school in all_schools
        }
        # Districts by ID
        self.__district_dict = {
            district.get_id(): district for district in all_districts
        }
        # District by School ID
        self.__assignment_dict = {}
        # Bordering Schools by District ID
        self.__bordering_dict = {}
        # Number of edges between Districts by District idxs
        self.__edge_tracker_matrix = None
        self.__district_id_to_edge_tracker_idx_dict = {}
        self.__edge_tracker_idx_to_district_id_dict = {}
        # Number of changes made to districts or their neighborhoods
        self.__neighborhood_change_counter_dict = {}
        
    def get_school_by_id(self, school_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.School instance through its
        standardized NCES ID.

        Args:
            school_id (str): Standardized school NCES ID.

        Returns:
            optimization.entity_nodes.School: School object instance.
        &#34;&#34;&#34;
        return self.__school_dict.get(school_id, None)
    
    def get_district_by_id(self, district_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.District instance through its
        standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            optimization.entity_nodes.District: District object instance.
        &#34;&#34;&#34;
        return self.__district_dict.get(district_id, None)
    
    def get_district_by_school_id(self, school_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.District instance to which a given
        school&#39;s standardized NCES ID is assigned to.

        Args:
            school_id (str): Standardized school NCES ID.

        Returns:
            optimization.entity_nodes.District: District object instance.
        &#34;&#34;&#34;
        return self.__assignment_dict.get(school_id, None)
    
    def get_bordering_schools_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the set of optimization.entity_nodes.School instances that belong
        to a district&#39;s border (i.e., that neighbor other districts) through its
        standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            set of optimization.entity_nodes.School: Set of School instances at
                the district&#39;s border.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve bordering schools wo/ complete district assignment...&#34;)
        return self.__bordering_dict.get(district_id, set([]))
    
    def get_neighboor_districts_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the set of optimization.entity_nodes.District instances that
        neighbor a specified district, through its standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            set of optimization.entity_nodes.District: Set of neighboring
                District instances.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve neighbor districts wo/ complete district assignment...&#34;)
        district_idx = self.__district_id_to_edge_tracker_idx_dict[district_id]
        neighbor_idxs = np.nonzero(self.__edge_tracker_matrix[district_idx])[0].tolist()
        neighbor_ids = set(map(lambda x: self.__edge_tracker_idx_to_district_id_dict[x], neighbor_idxs))
        return set(map(lambda x: self.get_district_by_id(x), neighbor_ids))
    
    def get_neighboorhood_changes_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the number of cumulative changes made to a district&#39;s neighborhood
        (i.e., number of schools redistricted) through its standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            int: Number of schools redistricted in District&#39;s neighborhood.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve neighborhood changes wo/ complete district assignment...&#34;)
        return self.__neighborhood_change_counter_dict.get(district_id, 0)
    
    def assign_school_to_district_by_id(self, school_id, new_district_id):
        &#34;&#34;&#34;
        Assigns a school to a district, through their respective standardized
        NCES IDs. If there exists a previous district assignment, the school is
        reassigned to the new district.

        Upon a school&#39;s reassignment to a new district, intermediate results are
        computed to speedup future lookups on the involved districts: (i)
        bordering schools are adjusted; (ii) neighboring edge count is adjusted;
        (iii) cumulative changes to both neighborhoods are incremented. At this 
        stage, knowing the reassigned school&#39;s neighbors trivializes all these
        operations and ammortizes computational complexity of the overall
        algorithm.

        Args:
            school_id (str): Standardized target school NCES ID.
            new_district_id (str): Standardized assignment district NCES ID.

        Raises:
            AssertionError: Whenever a school is reassigned to a different
                district, but isn&#39;t at its current district&#39;s border.
        &#34;&#34;&#34;
        old_district = self.get_district_by_school_id(school_id)
        new_district = self.get_district_by_id(new_district_id)
        
        if self.__all_schools_assigned:
            # Change district assignment
            assert(self.__is_school_in_district_border(school_id, new_district_id))
            self.__assignment_dict[school_id] = new_district
            # Update both district&#39;s bordering schools
            self.__update_bordering_schools_by_district_id(
                school_id,
                old_district.get_id(),
                new_district.get_id()
            )
            # Update both districts&#39; neighbor edge counts
            self.__update_district_neighborhoods_by_district_id(
                school_id,
                old_district.get_id(),
                new_district.get_id()
            )
            # Update neighboorhoods&#39; change counter
            self.__update_neighboorhood_change_counter(
                old_district.get_id(),
                new_district.get_id()
            )
        else:
            # Make new district assignment
            self.__assignment_dict[school_id] = new_district
            self.__handle_incomplete_district_assignment()
    
    def __handle_incomplete_district_assignment(self):
        &#34;&#34;&#34;
        Checks whether all schools are assigned to a district and updates
        __all_schools_assigned accordingly. The first time this flag is set to
        &#39;true&#39;, this method iterates over all schools and districts to
        initialize all necessary attributes for lookup speedup (i.e.,
        __edge_tracker_matrix, __district_id_to_edge_tracker_idx_dict,
        __edge_tracker_idx_to_district_id_dict, and
        __neighborhood_change_counter_dict).
        &#34;&#34;&#34;
        self.__all_schools_assigned = len(self.__school_dict) == len(self.__assignment_dict)
        if self.__all_schools_assigned:
            # Initialize edge tracking array (&amp; mapping function)
            self.__district_id_to_edge_tracker_idx_dict = dict(map(
                lambda x:(x[1],x[0]),
                enumerate(self.__district_dict.keys())
            ))
            reverse_dict = lambda x: {v:k for k,v in x.items()}
            self.__edge_tracker_idx_to_district_id_dict = reverse_dict(
                self.__district_id_to_edge_tracker_idx_dict
            )
            n_districts = len(self.__district_dict)
            self.__edge_tracker_matrix = np.zeros((n_districts,n_districts))
            # Initialize bordering dict &amp; district neighborhoods
            for district_id, district in self.__district_dict.items():
                for school in district.get_schools():
                    if self.__is_school_in_district_border(school.get_id()):
                        # Initialize bordering dict
                        cur_district_bordering = self.__bordering_dict.get(district_id, set([]))
                        cur_district_bordering.add(school)
                        self.__bordering_dict[district_id] = cur_district_bordering
            # Initialize district neighborhoods
            flatten = lambda l: [item for sublist in l for item in sublist]
            for district_id, district in self.__district_dict.items():
                all_school_neighbors = flatten(list(map(
                    lambda x: list(x.get_neighbors()),
                    district.get_schools()
                )))
                edge_count_by_district_id = Counter(map(
                    lambda x: self.get_district_by_school_id(x.get_id()).get_id(),
                    all_school_neighbors
                ))
                district_idx = self.__district_id_to_edge_tracker_idx_dict[district_id]
                for neighbor_district_id, edge_count in edge_count_by_district_id.items():
                    if district_id == neighbor_district_id:
                        continue
                    neighbor_district_idx = self.__district_id_to_edge_tracker_idx_dict[neighbor_district_id]
                    self.__edge_tracker_matrix[district_idx,neighbor_district_idx] = edge_count
                    self.__edge_tracker_matrix[neighbor_district_idx,district_idx] = edge_count
    
    def __is_school_in_district_border(self, school_id, with_district_id=None):
        &#34;&#34;&#34;
        Checks whether a school is at its assigned district&#39;s border. Beyond
        this first condition, this method can also check if a school is
        bordering a specific (neighboring) district.

        Args:
            school_id (str): Standardized target school NCES ID.
            with_district_id (str): Standardized neighboring district NCES ID,
                or None.

        Returns:
            bool: &#39;true&#39; if the school is at its assigned district&#39;s border
                (and, optionally, if it neighbors a specific district), &#39;false&#39;
                otherwise.
        &#34;&#34;&#34;
        school = self.get_school_by_id(school_id)
        district = self.get_district_by_school_id(school_id)
        for neighbor in school.get_neighbors():
            neighbor_district = self.get_district_by_school_id(neighbor.get_id())
            if neighbor_district.get_id() != district.get_id():
                if with_district_id is None:
                    return True
                elif with_district_id == neighbor_district.get_id():
                    return True
                else:
                    continue
        return False

    def __update_bordering_schools_by_district_id(self, moved_school_id, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the set of bordering schools for two districts involved in a
        school&#39;s district reassignment.

        Args:
            moved_school_id (str): Standardized target school NCES ID.
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        moved_school = self.get_school_by_id(moved_school_id)
        from_district = self.get_district_by_id(from_district_id)
        to_district = self.get_district_by_id(to_district_id)
        
        # Remove moved school from the &#34;bordering schools set&#34; of its previous district
        from_district_brodering_schools = self.__bordering_dict.get(from_district_id, set([]))
        from_district_brodering_schools.discard(moved_school)
        self.__bordering_dict[from_district_id] = from_district_brodering_schools
        # Update all moved schools&#39; neighbors (includig itself)
        for neighbor in [*moved_school.get_neighbors(), moved_school]:
            neighbor_district_id = self.get_district_by_school_id(neighbor.get_id()).get_id()
            neighbor_is_from_relevant_district = (
                (neighbor_district_id == from_district_id) or 
                (neighbor_district_id == to_district_id)
            )
            if neighbor_is_from_relevant_district:
                current_bordering_schools = self.__bordering_dict.get(neighbor_district_id, set([]))
                if self.__is_school_in_district_border(neighbor.get_id()):
                    current_bordering_schools.add(neighbor)
                else:
                    current_bordering_schools.discard(neighbor)
                self.__bordering_dict[neighbor_district_id] = current_bordering_schools
                
    def __update_district_neighborhoods_by_district_id(self, moved_school_id, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the set of neighboring districts for two districts involved in a
        school&#39;s district reassignment. It also updates the number of existing
        edges between involved pairs of neighbors.

        Args:
            moved_school_id (str): Standardized target school NCES ID.
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        # Get number of edges between moved school and its neighbors&#39; districts
        moved_school = self.get_school_by_id(moved_school_id)
        neighbor_district_ids = list(map(
            lambda x: self.get_district_by_school_id(x.get_id()).get_id(),
            moved_school.get_neighbors()
        ))
        # Get matrix idxs for all district ids
        from_district_idx = self.__district_id_to_edge_tracker_idx_dict[from_district_id]
        to_district_idx = self.__district_id_to_edge_tracker_idx_dict[to_district_id]
        # Update edge tracker matrix
        for neighbor_district_id, edge_count in Counter(neighbor_district_ids).items():
            neighbor_district_idx = self.__district_id_to_edge_tracker_idx_dict[neighbor_district_id]
            # Update edges existing between &#34;from&#34; and &#34;to&#34;
            if neighbor_district_id == from_district_id:
                self.__edge_tracker_matrix[from_district_idx,to_district_idx] += edge_count
                self.__edge_tracker_matrix[to_district_idx,from_district_idx] += edge_count
            elif neighbor_district_id == to_district_id:
                self.__edge_tracker_matrix[from_district_idx,to_district_idx] -= edge_count
                self.__edge_tracker_matrix[to_district_idx,from_district_idx] -= edge_count
            # Update edges existing between &#34;to&#34; and other districts
            else:
                # Remove edges that existed between &#34;from&#34; and neighbor
                self.__edge_tracker_matrix[from_district_idx,neighbor_district_idx] -= edge_count
                self.__edge_tracker_matrix[neighbor_district_idx,from_district_idx] -= edge_count
                # Add new edges created between &#34;to&#34; and neighbor
                self.__edge_tracker_matrix[to_district_idx,neighbor_district_idx] += edge_count
                self.__edge_tracker_matrix[neighbor_district_idx,to_district_idx] += edge_count
                
    def __update_neighboorhood_change_counter(self, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the number of cumulative changes (i.e., schools redistricted)
        for two districts involved in a school&#39;s district reassignment and their
        respective neighborhoods.

        Args:
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        # Auxiliary method for single counter increments
        def inc_counter(district_id):
            cur_counter = self.__neighborhood_change_counter_dict.get(district_id, 0)
            self.__neighborhood_change_counter_dict[district_id] = cur_counter + 1
        # Get immediate neighbor districts for &#34;from&#34; and &#34;to&#34; districts
        from_district_neighborhood = self.get_neighboor_districts_by_district_id(from_district_id)
        to_district_neighborhood = self.get_neighboor_districts_by_district_id(to_district_id)
        immediate_neighborhood = set([from_district_id, to_district_id]).union(
            from_district_neighborhood,
            to_district_neighborhood
        )
        # Update change counter for &#34;from&#34; and &#34;to&#34; districts directly
        for district_id in immediate_neighborhood:
            inc_counter(district_id)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="spatial_inequality.optimization.lookup.Lookup"><code class="flex name class">
<span>class <span class="ident">Lookup</span></span>
<span>(</span><span>all_schools, all_districts)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides several fast lookup methods for both
<code>optimization.entity_nodes.District</code> and <code>optimization.entity_nodes.School</code>
instances. The underlying data structures are also updated dynamically to
minimize computational complexity of certain operations (e.g., extracting
districts' neighborhoods from schools' neighborhoods).</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__school_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between standardized school NCES IDs and
their respective School instances.</dd>
<dt><strong><code>__district_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between standardized district NCES IDs
and their respective District instances.</dd>
<dt><strong><code>__assignment_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between standardized school NCES IDs
and the District instance they are assigned to.</dd>
<dt><strong><code>__bordering_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between standardized district NCES IDs
and School instances at their border (i.e., schools that neighbor
other districts).</dd>
<dt><strong><code>__edge_tracker_matrix</code></strong> :&ensp;<code>numpy.ndarray</code></dt>
<dd>Square matrix (2-dimensional
array), of 'districts x districts' dimensions, that contains the
amount of existing edges between any pair of districts.</dd>
<dt><strong><code>__district_id_to_edge_tracker_idx_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between
standardized district NCES IDs and their corresponding index in the
__edge_tracker_matrix.</dd>
<dt><strong><code>__edge_tracker_idx_to_district_id_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between a
district's index in the __edge_tracker_matrix and their respective
standardized NCES ID.</dd>
<dt><strong><code>__neighborhood_change_counter_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Mapping between standardized
district NCES IDs and the number of cumulative changes made in their
neihborhood (i.e., number of schools redistricted).</dd>
<dt><strong><code>__all_schools_assigned</code></strong> :&ensp;<code>bool</code></dt>
<dd>Initialization flag to signal whether all
schools have an assigned district</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lookup:
    &#34;&#34;&#34;
    This class provides several fast lookup methods for both
    `optimization.entity_nodes.District` and `optimization.entity_nodes.School`
    instances. The underlying data structures are also updated dynamically to
    minimize computational complexity of certain operations (e.g., extracting
    districts&#39; neighborhoods from schools&#39; neighborhoods).

    Attributes:
        __school_dict (dict): Mapping between standardized school NCES IDs and
            their respective School instances.
        __district_dict (dict): Mapping between standardized district NCES IDs
            and their respective District instances.
        __assignment_dict (dict): Mapping between standardized school NCES IDs
            and the District instance they are assigned to.
        __bordering_dict (dict): Mapping between standardized district NCES IDs
            and School instances at their border (i.e., schools that neighbor
            other districts).
        __edge_tracker_matrix (numpy.ndarray): Square matrix (2-dimensional
            array), of &#39;districts x districts&#39; dimensions, that contains the
            amount of existing edges between any pair of districts.
        __district_id_to_edge_tracker_idx_dict (dict): Mapping between
            standardized district NCES IDs and their corresponding index in the
            __edge_tracker_matrix.
        __edge_tracker_idx_to_district_id_dict (dict): Mapping between a
            district&#39;s index in the __edge_tracker_matrix and their respective
            standardized NCES ID.
        __neighborhood_change_counter_dict (dict): Mapping between standardized
            district NCES IDs and the number of cumulative changes made in their
            neihborhood (i.e., number of schools redistricted).
        __all_schools_assigned (bool): Initialization flag to signal whether all
            schools have an assigned district
    &#34;&#34;&#34;
    __school_dict = None
    __district_dict = None
    __assignment_dict = None
    __bordering_dict = None
    __edge_tracker_matrix = None
    __district_id_to_edge_tracker_idx_dict = None
    __edge_tracker_idx_to_district_id_dict = None
    __neighborhood_change_counter_dict = None
    __all_schools_assigned = False
    
    def __init__(self, all_schools, all_districts):
        # Schools by ID
        self.__school_dict = {
            school.get_id(): school for school in all_schools
        }
        # Districts by ID
        self.__district_dict = {
            district.get_id(): district for district in all_districts
        }
        # District by School ID
        self.__assignment_dict = {}
        # Bordering Schools by District ID
        self.__bordering_dict = {}
        # Number of edges between Districts by District idxs
        self.__edge_tracker_matrix = None
        self.__district_id_to_edge_tracker_idx_dict = {}
        self.__edge_tracker_idx_to_district_id_dict = {}
        # Number of changes made to districts or their neighborhoods
        self.__neighborhood_change_counter_dict = {}
        
    def get_school_by_id(self, school_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.School instance through its
        standardized NCES ID.

        Args:
            school_id (str): Standardized school NCES ID.

        Returns:
            optimization.entity_nodes.School: School object instance.
        &#34;&#34;&#34;
        return self.__school_dict.get(school_id, None)
    
    def get_district_by_id(self, district_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.District instance through its
        standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            optimization.entity_nodes.District: District object instance.
        &#34;&#34;&#34;
        return self.__district_dict.get(district_id, None)
    
    def get_district_by_school_id(self, school_id):
        &#34;&#34;&#34;
        Gets a optimization.entity_nodes.District instance to which a given
        school&#39;s standardized NCES ID is assigned to.

        Args:
            school_id (str): Standardized school NCES ID.

        Returns:
            optimization.entity_nodes.District: District object instance.
        &#34;&#34;&#34;
        return self.__assignment_dict.get(school_id, None)
    
    def get_bordering_schools_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the set of optimization.entity_nodes.School instances that belong
        to a district&#39;s border (i.e., that neighbor other districts) through its
        standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            set of optimization.entity_nodes.School: Set of School instances at
                the district&#39;s border.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve bordering schools wo/ complete district assignment...&#34;)
        return self.__bordering_dict.get(district_id, set([]))
    
    def get_neighboor_districts_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the set of optimization.entity_nodes.District instances that
        neighbor a specified district, through its standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            set of optimization.entity_nodes.District: Set of neighboring
                District instances.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve neighbor districts wo/ complete district assignment...&#34;)
        district_idx = self.__district_id_to_edge_tracker_idx_dict[district_id]
        neighbor_idxs = np.nonzero(self.__edge_tracker_matrix[district_idx])[0].tolist()
        neighbor_ids = set(map(lambda x: self.__edge_tracker_idx_to_district_id_dict[x], neighbor_idxs))
        return set(map(lambda x: self.get_district_by_id(x), neighbor_ids))
    
    def get_neighboorhood_changes_by_district_id(self, district_id):
        &#34;&#34;&#34;
        Gets the number of cumulative changes made to a district&#39;s neighborhood
        (i.e., number of schools redistricted) through its standardized NCES ID.

        Args:
            district_id (str): Standardized district NCES ID.

        Returns:
            int: Number of schools redistricted in District&#39;s neighborhood.

        Raises:
            ValueError: Whenever this method is called prior to finalizing
                school to district assignment.
        &#34;&#34;&#34;
        if not self.__all_schools_assigned:
            raise ValueError(&#34;Attempting to retrieve neighborhood changes wo/ complete district assignment...&#34;)
        return self.__neighborhood_change_counter_dict.get(district_id, 0)
    
    def assign_school_to_district_by_id(self, school_id, new_district_id):
        &#34;&#34;&#34;
        Assigns a school to a district, through their respective standardized
        NCES IDs. If there exists a previous district assignment, the school is
        reassigned to the new district.

        Upon a school&#39;s reassignment to a new district, intermediate results are
        computed to speedup future lookups on the involved districts: (i)
        bordering schools are adjusted; (ii) neighboring edge count is adjusted;
        (iii) cumulative changes to both neighborhoods are incremented. At this 
        stage, knowing the reassigned school&#39;s neighbors trivializes all these
        operations and ammortizes computational complexity of the overall
        algorithm.

        Args:
            school_id (str): Standardized target school NCES ID.
            new_district_id (str): Standardized assignment district NCES ID.

        Raises:
            AssertionError: Whenever a school is reassigned to a different
                district, but isn&#39;t at its current district&#39;s border.
        &#34;&#34;&#34;
        old_district = self.get_district_by_school_id(school_id)
        new_district = self.get_district_by_id(new_district_id)
        
        if self.__all_schools_assigned:
            # Change district assignment
            assert(self.__is_school_in_district_border(school_id, new_district_id))
            self.__assignment_dict[school_id] = new_district
            # Update both district&#39;s bordering schools
            self.__update_bordering_schools_by_district_id(
                school_id,
                old_district.get_id(),
                new_district.get_id()
            )
            # Update both districts&#39; neighbor edge counts
            self.__update_district_neighborhoods_by_district_id(
                school_id,
                old_district.get_id(),
                new_district.get_id()
            )
            # Update neighboorhoods&#39; change counter
            self.__update_neighboorhood_change_counter(
                old_district.get_id(),
                new_district.get_id()
            )
        else:
            # Make new district assignment
            self.__assignment_dict[school_id] = new_district
            self.__handle_incomplete_district_assignment()
    
    def __handle_incomplete_district_assignment(self):
        &#34;&#34;&#34;
        Checks whether all schools are assigned to a district and updates
        __all_schools_assigned accordingly. The first time this flag is set to
        &#39;true&#39;, this method iterates over all schools and districts to
        initialize all necessary attributes for lookup speedup (i.e.,
        __edge_tracker_matrix, __district_id_to_edge_tracker_idx_dict,
        __edge_tracker_idx_to_district_id_dict, and
        __neighborhood_change_counter_dict).
        &#34;&#34;&#34;
        self.__all_schools_assigned = len(self.__school_dict) == len(self.__assignment_dict)
        if self.__all_schools_assigned:
            # Initialize edge tracking array (&amp; mapping function)
            self.__district_id_to_edge_tracker_idx_dict = dict(map(
                lambda x:(x[1],x[0]),
                enumerate(self.__district_dict.keys())
            ))
            reverse_dict = lambda x: {v:k for k,v in x.items()}
            self.__edge_tracker_idx_to_district_id_dict = reverse_dict(
                self.__district_id_to_edge_tracker_idx_dict
            )
            n_districts = len(self.__district_dict)
            self.__edge_tracker_matrix = np.zeros((n_districts,n_districts))
            # Initialize bordering dict &amp; district neighborhoods
            for district_id, district in self.__district_dict.items():
                for school in district.get_schools():
                    if self.__is_school_in_district_border(school.get_id()):
                        # Initialize bordering dict
                        cur_district_bordering = self.__bordering_dict.get(district_id, set([]))
                        cur_district_bordering.add(school)
                        self.__bordering_dict[district_id] = cur_district_bordering
            # Initialize district neighborhoods
            flatten = lambda l: [item for sublist in l for item in sublist]
            for district_id, district in self.__district_dict.items():
                all_school_neighbors = flatten(list(map(
                    lambda x: list(x.get_neighbors()),
                    district.get_schools()
                )))
                edge_count_by_district_id = Counter(map(
                    lambda x: self.get_district_by_school_id(x.get_id()).get_id(),
                    all_school_neighbors
                ))
                district_idx = self.__district_id_to_edge_tracker_idx_dict[district_id]
                for neighbor_district_id, edge_count in edge_count_by_district_id.items():
                    if district_id == neighbor_district_id:
                        continue
                    neighbor_district_idx = self.__district_id_to_edge_tracker_idx_dict[neighbor_district_id]
                    self.__edge_tracker_matrix[district_idx,neighbor_district_idx] = edge_count
                    self.__edge_tracker_matrix[neighbor_district_idx,district_idx] = edge_count
    
    def __is_school_in_district_border(self, school_id, with_district_id=None):
        &#34;&#34;&#34;
        Checks whether a school is at its assigned district&#39;s border. Beyond
        this first condition, this method can also check if a school is
        bordering a specific (neighboring) district.

        Args:
            school_id (str): Standardized target school NCES ID.
            with_district_id (str): Standardized neighboring district NCES ID,
                or None.

        Returns:
            bool: &#39;true&#39; if the school is at its assigned district&#39;s border
                (and, optionally, if it neighbors a specific district), &#39;false&#39;
                otherwise.
        &#34;&#34;&#34;
        school = self.get_school_by_id(school_id)
        district = self.get_district_by_school_id(school_id)
        for neighbor in school.get_neighbors():
            neighbor_district = self.get_district_by_school_id(neighbor.get_id())
            if neighbor_district.get_id() != district.get_id():
                if with_district_id is None:
                    return True
                elif with_district_id == neighbor_district.get_id():
                    return True
                else:
                    continue
        return False

    def __update_bordering_schools_by_district_id(self, moved_school_id, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the set of bordering schools for two districts involved in a
        school&#39;s district reassignment.

        Args:
            moved_school_id (str): Standardized target school NCES ID.
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        moved_school = self.get_school_by_id(moved_school_id)
        from_district = self.get_district_by_id(from_district_id)
        to_district = self.get_district_by_id(to_district_id)
        
        # Remove moved school from the &#34;bordering schools set&#34; of its previous district
        from_district_brodering_schools = self.__bordering_dict.get(from_district_id, set([]))
        from_district_brodering_schools.discard(moved_school)
        self.__bordering_dict[from_district_id] = from_district_brodering_schools
        # Update all moved schools&#39; neighbors (includig itself)
        for neighbor in [*moved_school.get_neighbors(), moved_school]:
            neighbor_district_id = self.get_district_by_school_id(neighbor.get_id()).get_id()
            neighbor_is_from_relevant_district = (
                (neighbor_district_id == from_district_id) or 
                (neighbor_district_id == to_district_id)
            )
            if neighbor_is_from_relevant_district:
                current_bordering_schools = self.__bordering_dict.get(neighbor_district_id, set([]))
                if self.__is_school_in_district_border(neighbor.get_id()):
                    current_bordering_schools.add(neighbor)
                else:
                    current_bordering_schools.discard(neighbor)
                self.__bordering_dict[neighbor_district_id] = current_bordering_schools
                
    def __update_district_neighborhoods_by_district_id(self, moved_school_id, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the set of neighboring districts for two districts involved in a
        school&#39;s district reassignment. It also updates the number of existing
        edges between involved pairs of neighbors.

        Args:
            moved_school_id (str): Standardized target school NCES ID.
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        # Get number of edges between moved school and its neighbors&#39; districts
        moved_school = self.get_school_by_id(moved_school_id)
        neighbor_district_ids = list(map(
            lambda x: self.get_district_by_school_id(x.get_id()).get_id(),
            moved_school.get_neighbors()
        ))
        # Get matrix idxs for all district ids
        from_district_idx = self.__district_id_to_edge_tracker_idx_dict[from_district_id]
        to_district_idx = self.__district_id_to_edge_tracker_idx_dict[to_district_id]
        # Update edge tracker matrix
        for neighbor_district_id, edge_count in Counter(neighbor_district_ids).items():
            neighbor_district_idx = self.__district_id_to_edge_tracker_idx_dict[neighbor_district_id]
            # Update edges existing between &#34;from&#34; and &#34;to&#34;
            if neighbor_district_id == from_district_id:
                self.__edge_tracker_matrix[from_district_idx,to_district_idx] += edge_count
                self.__edge_tracker_matrix[to_district_idx,from_district_idx] += edge_count
            elif neighbor_district_id == to_district_id:
                self.__edge_tracker_matrix[from_district_idx,to_district_idx] -= edge_count
                self.__edge_tracker_matrix[to_district_idx,from_district_idx] -= edge_count
            # Update edges existing between &#34;to&#34; and other districts
            else:
                # Remove edges that existed between &#34;from&#34; and neighbor
                self.__edge_tracker_matrix[from_district_idx,neighbor_district_idx] -= edge_count
                self.__edge_tracker_matrix[neighbor_district_idx,from_district_idx] -= edge_count
                # Add new edges created between &#34;to&#34; and neighbor
                self.__edge_tracker_matrix[to_district_idx,neighbor_district_idx] += edge_count
                self.__edge_tracker_matrix[neighbor_district_idx,to_district_idx] += edge_count
                
    def __update_neighboorhood_change_counter(self, from_district_id, to_district_id):
        &#34;&#34;&#34;
        Updates the number of cumulative changes (i.e., schools redistricted)
        for two districts involved in a school&#39;s district reassignment and their
        respective neighborhoods.

        Args:
            from_district_id (str): Standardized source district NCES ID.
            to_district_id (str): Standardized destination district NCES ID.
        &#34;&#34;&#34;
        # Auxiliary method for single counter increments
        def inc_counter(district_id):
            cur_counter = self.__neighborhood_change_counter_dict.get(district_id, 0)
            self.__neighborhood_change_counter_dict[district_id] = cur_counter + 1
        # Get immediate neighbor districts for &#34;from&#34; and &#34;to&#34; districts
        from_district_neighborhood = self.get_neighboor_districts_by_district_id(from_district_id)
        to_district_neighborhood = self.get_neighboor_districts_by_district_id(to_district_id)
        immediate_neighborhood = set([from_district_id, to_district_id]).union(
            from_district_neighborhood,
            to_district_neighborhood
        )
        # Update change counter for &#34;from&#34; and &#34;to&#34; districts directly
        for district_id in immediate_neighborhood:
            inc_counter(district_id)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="spatial_inequality.optimization.lookup.Lookup.assign_school_to_district_by_id"><code class="name flex">
<span>def <span class="ident">assign_school_to_district_by_id</span></span>(<span>self, school_id, new_district_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Assigns a school to a district, through their respective standardized
NCES IDs. If there exists a previous district assignment, the school is
reassigned to the new district.</p>
<p>Upon a school's reassignment to a new district, intermediate results are
computed to speedup future lookups on the involved districts: (i)
bordering schools are adjusted; (ii) neighboring edge count is adjusted;
(iii) cumulative changes to both neighborhoods are incremented. At this
stage, knowing the reassigned school's neighbors trivializes all these
operations and ammortizes computational complexity of the overall
algorithm.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>school_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized target school NCES ID.</dd>
<dt><strong><code>new_district_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized assignment district NCES ID.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>Whenever a school is reassigned to a different
district, but isn't at its current district's border.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assign_school_to_district_by_id(self, school_id, new_district_id):
    &#34;&#34;&#34;
    Assigns a school to a district, through their respective standardized
    NCES IDs. If there exists a previous district assignment, the school is
    reassigned to the new district.

    Upon a school&#39;s reassignment to a new district, intermediate results are
    computed to speedup future lookups on the involved districts: (i)
    bordering schools are adjusted; (ii) neighboring edge count is adjusted;
    (iii) cumulative changes to both neighborhoods are incremented. At this 
    stage, knowing the reassigned school&#39;s neighbors trivializes all these
    operations and ammortizes computational complexity of the overall
    algorithm.

    Args:
        school_id (str): Standardized target school NCES ID.
        new_district_id (str): Standardized assignment district NCES ID.

    Raises:
        AssertionError: Whenever a school is reassigned to a different
            district, but isn&#39;t at its current district&#39;s border.
    &#34;&#34;&#34;
    old_district = self.get_district_by_school_id(school_id)
    new_district = self.get_district_by_id(new_district_id)
    
    if self.__all_schools_assigned:
        # Change district assignment
        assert(self.__is_school_in_district_border(school_id, new_district_id))
        self.__assignment_dict[school_id] = new_district
        # Update both district&#39;s bordering schools
        self.__update_bordering_schools_by_district_id(
            school_id,
            old_district.get_id(),
            new_district.get_id()
        )
        # Update both districts&#39; neighbor edge counts
        self.__update_district_neighborhoods_by_district_id(
            school_id,
            old_district.get_id(),
            new_district.get_id()
        )
        # Update neighboorhoods&#39; change counter
        self.__update_neighboorhood_change_counter(
            old_district.get_id(),
            new_district.get_id()
        )
    else:
        # Make new district assignment
        self.__assignment_dict[school_id] = new_district
        self.__handle_incomplete_district_assignment()</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_bordering_schools_by_district_id"><code class="name flex">
<span>def <span class="ident">get_bordering_schools_by_district_id</span></span>(<span>self, district_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the set of optimization.entity_nodes.School instances that belong
to a district's border (i.e., that neighbor other districts) through its
standardized NCES ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>district_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized district NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code> of <code>optimization.entity_nodes.School</code></dt>
<dd>Set of School instances at
the district's border.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Whenever this method is called prior to finalizing
school to district assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bordering_schools_by_district_id(self, district_id):
    &#34;&#34;&#34;
    Gets the set of optimization.entity_nodes.School instances that belong
    to a district&#39;s border (i.e., that neighbor other districts) through its
    standardized NCES ID.

    Args:
        district_id (str): Standardized district NCES ID.

    Returns:
        set of optimization.entity_nodes.School: Set of School instances at
            the district&#39;s border.

    Raises:
        ValueError: Whenever this method is called prior to finalizing
            school to district assignment.
    &#34;&#34;&#34;
    if not self.__all_schools_assigned:
        raise ValueError(&#34;Attempting to retrieve bordering schools wo/ complete district assignment...&#34;)
    return self.__bordering_dict.get(district_id, set([]))</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_district_by_id"><code class="name flex">
<span>def <span class="ident">get_district_by_id</span></span>(<span>self, district_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a optimization.entity_nodes.District instance through its
standardized NCES ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>district_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized district NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>optimization.entity_nodes.District</code></dt>
<dd>District object instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_district_by_id(self, district_id):
    &#34;&#34;&#34;
    Gets a optimization.entity_nodes.District instance through its
    standardized NCES ID.

    Args:
        district_id (str): Standardized district NCES ID.

    Returns:
        optimization.entity_nodes.District: District object instance.
    &#34;&#34;&#34;
    return self.__district_dict.get(district_id, None)</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_district_by_school_id"><code class="name flex">
<span>def <span class="ident">get_district_by_school_id</span></span>(<span>self, school_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a optimization.entity_nodes.District instance to which a given
school's standardized NCES ID is assigned to.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>school_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized school NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>optimization.entity_nodes.District</code></dt>
<dd>District object instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_district_by_school_id(self, school_id):
    &#34;&#34;&#34;
    Gets a optimization.entity_nodes.District instance to which a given
    school&#39;s standardized NCES ID is assigned to.

    Args:
        school_id (str): Standardized school NCES ID.

    Returns:
        optimization.entity_nodes.District: District object instance.
    &#34;&#34;&#34;
    return self.__assignment_dict.get(school_id, None)</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_neighboor_districts_by_district_id"><code class="name flex">
<span>def <span class="ident">get_neighboor_districts_by_district_id</span></span>(<span>self, district_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the set of optimization.entity_nodes.District instances that
neighbor a specified district, through its standardized NCES ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>district_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized district NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code> of <code>optimization.entity_nodes.District</code></dt>
<dd>Set of neighboring
District instances.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Whenever this method is called prior to finalizing
school to district assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighboor_districts_by_district_id(self, district_id):
    &#34;&#34;&#34;
    Gets the set of optimization.entity_nodes.District instances that
    neighbor a specified district, through its standardized NCES ID.

    Args:
        district_id (str): Standardized district NCES ID.

    Returns:
        set of optimization.entity_nodes.District: Set of neighboring
            District instances.

    Raises:
        ValueError: Whenever this method is called prior to finalizing
            school to district assignment.
    &#34;&#34;&#34;
    if not self.__all_schools_assigned:
        raise ValueError(&#34;Attempting to retrieve neighbor districts wo/ complete district assignment...&#34;)
    district_idx = self.__district_id_to_edge_tracker_idx_dict[district_id]
    neighbor_idxs = np.nonzero(self.__edge_tracker_matrix[district_idx])[0].tolist()
    neighbor_ids = set(map(lambda x: self.__edge_tracker_idx_to_district_id_dict[x], neighbor_idxs))
    return set(map(lambda x: self.get_district_by_id(x), neighbor_ids))</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_neighboorhood_changes_by_district_id"><code class="name flex">
<span>def <span class="ident">get_neighboorhood_changes_by_district_id</span></span>(<span>self, district_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the number of cumulative changes made to a district's neighborhood
(i.e., number of schools redistricted) through its standardized NCES ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>district_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized district NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of schools redistricted in District's neighborhood.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Whenever this method is called prior to finalizing
school to district assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_neighboorhood_changes_by_district_id(self, district_id):
    &#34;&#34;&#34;
    Gets the number of cumulative changes made to a district&#39;s neighborhood
    (i.e., number of schools redistricted) through its standardized NCES ID.

    Args:
        district_id (str): Standardized district NCES ID.

    Returns:
        int: Number of schools redistricted in District&#39;s neighborhood.

    Raises:
        ValueError: Whenever this method is called prior to finalizing
            school to district assignment.
    &#34;&#34;&#34;
    if not self.__all_schools_assigned:
        raise ValueError(&#34;Attempting to retrieve neighborhood changes wo/ complete district assignment...&#34;)
    return self.__neighborhood_change_counter_dict.get(district_id, 0)</code></pre>
</details>
</dd>
<dt id="spatial_inequality.optimization.lookup.Lookup.get_school_by_id"><code class="name flex">
<span>def <span class="ident">get_school_by_id</span></span>(<span>self, school_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a optimization.entity_nodes.School instance through its
standardized NCES ID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>school_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Standardized school NCES ID.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>optimization.entity_nodes.School</code></dt>
<dd>School object instance.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_school_by_id(self, school_id):
    &#34;&#34;&#34;
    Gets a optimization.entity_nodes.School instance through its
    standardized NCES ID.

    Args:
        school_id (str): Standardized school NCES ID.

    Returns:
        optimization.entity_nodes.School: School object instance.
    &#34;&#34;&#34;
    return self.__school_dict.get(school_id, None)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spatial_inequality.optimization" href="index.html">spatial_inequality.optimization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="spatial_inequality.optimization.lookup.Lookup" href="#spatial_inequality.optimization.lookup.Lookup">Lookup</a></code></h4>
<ul class="">
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.assign_school_to_district_by_id" href="#spatial_inequality.optimization.lookup.Lookup.assign_school_to_district_by_id">assign_school_to_district_by_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_bordering_schools_by_district_id" href="#spatial_inequality.optimization.lookup.Lookup.get_bordering_schools_by_district_id">get_bordering_schools_by_district_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_district_by_id" href="#spatial_inequality.optimization.lookup.Lookup.get_district_by_id">get_district_by_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_district_by_school_id" href="#spatial_inequality.optimization.lookup.Lookup.get_district_by_school_id">get_district_by_school_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_neighboor_districts_by_district_id" href="#spatial_inequality.optimization.lookup.Lookup.get_neighboor_districts_by_district_id">get_neighboor_districts_by_district_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_neighboorhood_changes_by_district_id" href="#spatial_inequality.optimization.lookup.Lookup.get_neighboorhood_changes_by_district_id">get_neighboorhood_changes_by_district_id</a></code></li>
<li><code><a title="spatial_inequality.optimization.lookup.Lookup.get_school_by_id" href="#spatial_inequality.optimization.lookup.Lookup.get_school_by_id">get_school_by_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>